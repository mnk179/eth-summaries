\documentclass[11pt,oneside,a4paper]{article}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{lscape}
\usepackage{psfrag}
\usepackage[usenames]{color}
\usepackage{bbm}
\usepackage[update]{epstopdf}
\usepackage[bookmarks,pdfstartview=FitH,a4paper,pdfborder={0 0 0}]{hyperref}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{fancyhdr}
\usepackage{multirow}
\usepackage{tikz}
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{wrapfig}
\usepackage[margin=1in]{geometry}
\usepackage{pdfpages}
\newcommand{\hint}[1]{{\color{blue} \em #1}}

\makeatletter
\def\cleardoublepage{\clearpage\if@twoside \ifodd\c@page\else%
\hbox{}%
\thispagestyle{empty}%
\clearpage%
\if@twocolumn\hbox{}\clearpage\fi\fi\fi}
\makeatother

\sloppy
% \widowpenalty=10000
% \clubpenalty=10000

\title{
    \vspace*{0.0mm}
    \LARGE\bf\sf Network Security (Fall 2019)
    \vspace*{10.0mm} \\
    %
    \Huge\bf\sf Summary
    %
    \vspace*{30.0mm} \\
    \normalsize
    %
    \sf Author:\\[5pt]
    \sf Yannick Merkli\\ [5pt]
    \sf \pageref{lastpage} Pages
}
\date{}

\begin{document}

\maketitle
\thispagestyle{empty}
\raggedbottom
\clearpage

\pagenumbering{roman}

\clearpage
\setcounter{tocdepth}{2}
\tableofcontents
\clearpage
\pagenumbering{arabic}

\begin{center}
	\noindent \textbf{\LARGE Disclaimer: Legal use of the material}
	
	\noindent Some knowledge, technologies, code is usable for attacks, it is illegal to use them for criminal activities. It is also illegal to make available such technologies and code without proper measures.\\
	This summary is based on \cite{netsec}.
\end{center}


\newpage

\section{SSL, TLS, PKI}

\subsection{SSL/TLS Overview}

Goal: Secure Internet communication.\\
We need \textit{secrecy} to precent eavesdroppers from learning sensitive information and we need entity and message authentication to prevent message alteration/ injection.

\subsection{PKI overview}

In symmetric cryptography, main challenge is key distribution as keys need to be distributed via confidential and authentic channels. In public-key systems, main challenge is key authentication (i.e., which key belongs to whom) as keys need to be distributed via authentic channels.\\
\textit{Public-key infrastructures (PKIs) provide a way to validate public keys}.\\

\noindent Terminology: 

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item PKI: Public-key infrastructures
	\item CA: Certification authority
	\item A public-key certificate (or simply certificate) is signed and binds a name to a public key \item Trust anchor, trust root: self-signed certificates of public keys that are allowed to sign other certificates.
	\item X.509: standard format of digital certificate, defines a structure for public key certificates: Two sections: data and signature section.
\end{itemize}
\vspace{-\topsep}

\noindent Trust establishment: You cannot establish trust out of thin air - we need a root of trust to establish trust in other entities. Cryptographic operations enable transfer of trust from one entity to another.

\subsection{X.509}

X.509 defines a structure for public key certificates

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Two sections: data and signature sec1on
	\item A CA assigns a unique name to each user and issues a signed certificate
	\item Often name is the domain or Email address
	\item Each CA issues a certificate for those beneath it
\end{itemize}
\vspace{-\topsep}

\noindent Multi-Domain Certificates are possible and used e.g. by CDNs. Content Delivery Networks (CDN) are hosting web sites for domains and thus need a certificate to service content. CDNs are obtaining a single certificate for multiple domains.

\subsection{Compelled Certificates}

Compelled certificate: public/private key pair for law enforcement (MitM attacks on TLS) with CA certificate enabling private key to sign additional certificates. Compelled certificates carry inherent risks: Since the certificates are non-repudiable, anyone who gets hold of the second valid certificate the CA's or the government's involvement in a compelled certificate creation attack. This results in a loss of trust in the CA or the government. If the CA creates an intermediary CA certificate for the government, then that certificate would have to be registered in a CT log, but in that case, the attack
does not become directly attributable to VeriSign, as the forged certificate is signed by the intermediary certificate.

\newpage

\subsection{Approaches to improve TLS}

\subsubsection{The “Let’s Encrypt” CA}

Goal: provide free certificates with automatic domain validation, issuance, and renewal. It uses relatively short-lived certificates (90 days). It is based on ACME (Automated Certificate Management Environment).

\subsubsection{Levels of trust}

Have different levels of trust in certificates:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item No SSL/TLS
	\item Domain validation (DV): the domain is validated but the owner could be malicious (e.g. bad.com with certificate for bad.com)
	\item Organization validation (OV) / "High assurance": A certificate provider will issue an OV class certificate to a purchaser if the purchaser can meet two criteria: the right to administratively manage the domain name in question, and perhaps, the organization's actual existence as a legal entity. (e.g. wikipedia.org)
	\item Extended validation (EV): can be issued only by a subset of certificate authorities (CAs) and require verification of the requesting entity's legal identity before certificate issuance (e.g. credit-suisse.com). They are further displayed differently in most browsers. 
\end{itemize}
\vspace{-\topsep}

\subsubsection{HTTP Strict Transport Security (HSTS)}

Goal: allows servers to declare that their clients should only use HTTPS (for a specified period). This prevents some “downgrade”, “SSL stripping”, and “session hijacking” attacks. Browsers should automatically redirect to HTTPs or display a warning message. HSTS is implemented with an HTTPS header. Example: \\
\indent \texttt{Strict-Transport-Security: max-age=31536000}\\
\noindent HSTS doesn't help at all if valid bogus certificates are used.

\subsubsection{HTTP Public-Key Pinning (HPKP)}

A server implementing HPKP will provide the client with a list of hashes of valid
certificates for the domain. This list is delivered in an HTTP header that also contains a
max-age value. The client will then “pin” those hashes — subsequent connection within the
max-age period will only succeed if the certificate offered by the server matches the pinned
hashes for that domain. A MitM with a different certificate would therefore fail. Example:\\
\indent \texttt{Public-Key-Pins: max-age=2592000; pin-sha256="..."; pin-sha256="...";\\
	\indent report-uri="...";\\
}
MiTM attacks can still succeed even with HPKP: HPKP is TOFU (Trust On First Use). If the first policy received comes from an
attacker, the browser will be happy to communicate with the bogus website and will block
the legitimate server. Also if a weak hash function is used, the attacker could generate a
certificate with a colliding hash — but in that case HPKP would be the last of our problems.\\

\noindent Further problem with HPKP: certificates can change often (e.g with Let's encrypt). If a certificate changes but users still hold the old policy (since the max-age hasn't expired yet), clients won't accept the new certificate although it is legitimate.

\newpage

\subsubsection{Certificate revocation}

Certificate revocation is a mechanism to invalidate certificates (e.g. after a private key is disclosed or after a trusted employee leaves a company). CA periodically publishes certificate revocation List (CRL).\\
Problem: CAP theorem (Consistency, Availability, tolerance to Par11on):
impossible to achieve all 3, need to sacrifice one!

\subsubsection{Online Certificate Status Protocol (OCSP)}

Online Certificate Status Protocol (OCSP) to verify certificate status, ensure certificate is valid and has not been revoked. Browsers will send certs to OCSP server for verification.\\
Problem: 
\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item “Optimistic” treatment of OCSP failure information: If OCSP server does not respond, a certificate would be considered invalid, although the certificate most likely isn't. This leads to false positives, which is annoying for browser users, that's why most browsers don't treat a non-responding OCSP server as invalid certificate.
	\item OCSP servers can be slow, which is another reason for browsers to deactivate it by default, since users otherwise may switch browsers.
	\item OCSP can leak browsing information outside of private browsing mode as Microsoft’s CryptoAPI and Apple’s Security Framework API cache OCSP responses in OS.
\end{itemize}
\vspace{-\topsep} 

\noindent Possible solution: OCSP stapling allows the presenter of a certificate to bear the resource cost involved in providing OCSP responses by appending ("stapling") a time-stamped OCSP response signed by the CA to the initial TLS handshake, eliminating the need for clients to contact the CA, with the aim of improving both security and performance.

\subsubsection{DNS-Based Authentica1on of Named Entities (DANE)}

Goal: authenticate TLS servers without a certificate authority (CA). DANE uses DNSSEC to bind certificates to names. Problem: this is heavily reliant on DNSSEC.

\subsubsection{Attack-resilient PKI (ARPKI)}

Goal: reduce trust in any single component (e.g. CA, log server, etc.). Reduce attack surface, no single point of failure.\\
ARPKI has a set of entities that audit each other's operation and disseminate misbehavior if detected:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Client (browser) establishes TLS connections with	Domain
	\item Integrity Log Server (ILS) logs domains’ certificates, makes logs publicly available and maintains Integrity Tree
	\item Certification Authority (CA) certifies domains’ public keys, download ILS data and check consistency and check behavior of other CAs.
\end{itemize}
\vspace{-\topsep}

\noindent ARPKI communication flows:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Domains obtain certificate with multiple signatures from different CAs
	\item CAs also act as validators to survey operation by ILSes. They download accepted requests and validate log
	\item $n$ parties are needed for valid certificate (ILS and $n-1$ parties are different CAs)
\end{itemize}
\vspace{-\topsep}

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.5\linewidth]{figures/arpki}
	\caption{ARPKI}
	\label{fig:arpki}
\end{figure}

\newpage

\subsubsection{Certificate transparency (CT)}

Certificate	Transparency will make all public end-entity TLS certificates public knowledge,	and	will hold CAs publicly accountable for all certificates they issue. And it will do so without introducing another trusted third party.\\
\noindent CT uses a CT log that is an append-only list of certificates. The log server verifies the certificate chain (CA attribution for certificate miss-issuance and spam control). Periodically, all new certificates are appended to the append-only log and that list is then signed. All updates of the signed list of certificates ("the log") are published to the world. The CT log is implemented as a merkle hash tree. We have three participants in the protocol:

\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{figures/tls_with_ct}
	\caption{TLS with certificate transparency}
	\label{fig:tlswithct}
\end{figure}


\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Log Server. Contains a list of certificates that is publicly available. Must
	add the certificates submitted by the CAs.
	\item Clients (auditors). Can verify the existence of certificates by checking the log server,
	and exchange information with the monitors about the log server status, in order to
	ensure the log server is not compromised.
	\item CAs (monitors). Request the addition of every newly issued cert, check that the log
	server actually adds the certificates, monitor what the other CAs are doing.
	\item Certificate owners: Query monitors to verify that nobody has logged illegitimate certs for their domain.
\end{itemize}
\vspace{-\topsep}

\newpage

\noindent Upon receiving a new certificate chain from domain or CA: the log verifies the certificate, issues a signed certificate timestamp (SCT) and promises to add the new certificate to the MHT (SCT is necessary since certs are only periodically added to log).\\
How does CT handle revocation? The certificates stay on the log forever: Merkle trees allow for easy insertion but not for immediate deletion. The current system implements revocation transparency, which is very similar to CT, but for revocation requests.\\

\noindent Disadvantages of CT:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item MitM attack still proceeds (but can be detected externally)
	\item Browser still needs to contact Log eventually to verify that certificate is listed in log
	\item Malicious Log server can add bogus certificate
\end{itemize}
\vspace{-\topsep}

\begin{figure}[hb]
	\centering
	\includegraphics[width=0.6\linewidth]{figures/ct_summary}
	\caption{CT summary}
	\label{fig:ctsummary}
\end{figure}

\begin{figure}[hb]
	\centering
	\includegraphics[width=0.5\linewidth]{figures/ct_participants}
	\caption{CT participants}
	\label{fig:ctparticipants}
\end{figure}



\newpage

\section{TLS}

Perfect forward secrecy: when obtaining a private key, I can only decrypt future sessions, not past ones.

\subsection{Cipher suites}

\texttt{TLS\_\{KEY\_EXCHANGE\}\_\{AUTHENTICATION\}\_WITH\_\{BULK\_ENCRYPTION\}\_\{MAC\}}

\noindent Example: \texttt{TLS\_DHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256}\\
Key exchange: Ephemeral Diffie-Hellman, Authentication: RSA, Encryption: 128-bit AES GCM mode, MAC: 256-bit SHA-2

\subsection{Handshake protocol}

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Establishes keys needed by the Record Protocol, via establishment of the TLS mastersecret and subsequent key derivation.
	\item Provides authentication of server (usually) and client (rarely), using public key cryptography supported by digital certificates or pre-shared key (less common, used in IoT).
	\item Protects negotiation of all cryptographic parameters. SSL/TLS version number, encryption and hash algorithms, authentication and key establishment methods. This prevents version rollback and cipher suite downgrade attacks.
\end{itemize}
\vspace{-\topsep}

\begin{figure}[hb]
	\centering
	\includegraphics[width=0.4\linewidth]{figures/tls_key_derivation}
	\caption{TLS key derivation. The premastersecret is either a client-generated random-value (RSA) or the negotiated DH shared secret (DH). Nonces are public. All symmetric keys come from the key\_block (48 bytes). The split of the key\_block depends on the cipher suite.}
	\label{fig:tlskeyderivation}
\end{figure}


\subsubsection{Key establishment options}

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item RSA: RSA key generation is expensive, that's why keys are reused. Thus, RSA does not provide perfect forward secrecy.
	\item Static Diffie-Hellman: Server certificate contains DH parameters (group, generator g)
	and static DH value $g^x$. Client chooses y, computes $g^y$ and sends to server. $$premastersecret = g^{xy}$$
	Thus, Static Diffie-Hellman does not provide perfect forward secrecy.
	\item Anonymous Diffie-Hellman: Each side sends Diffie-Hellman values in group chosen by
	server, but no authentication of these values. Vulnerable to man-in-middle attacks even if only offered.
	\item The key exchange is called “ephemeral” if the client and server both choose a new key pair for every exchange. Ephemeral key exchanges offer PFS.
	\item (EC)DHE: Offers perfect forward secrecy.
\end{itemize}
\vspace{-\topsep}

\newpage

\subsection{Record protocol}

TLS Record Protocol uses symmetric encryption, using the keys negotiated during the handshake protocol. It provides:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Data origin authentication, integrity using a MAC.
	\item Confidentiality using a symmetric encryption algorithm.
	\item Anti-replay using sequence numbers protected by the MAC.
	\item Optional compression.
	\item A stream-oriented API for applications making use of it.
	\item Hence TLS may fragment into smaller records or coalesce into larger records any data supplied by the calling application.
\end{itemize}
\vspace{-\topsep}

\noindent Different record layer encryption schemes:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item AES is secure in both 128-bit and 256-bit mode (and more), however if CBC mode is used, padding oracle attacks are possible. GCM mode is secure.
	\item DES is not secure.
	\item RC4 is not secure (see \ref{attack_on_rc4})
\end{itemize}
\vspace{-\topsep}

\noindent The TLS record protocol uses MAC-then-encrypt: this is \textit{really really bad} since this opens up the possibility of padding oracle attacks!

\begin{figure}[hb]
	\centering
	\includegraphics[width=0.4\linewidth]{figures/tls_record_protocol}
	\caption{TLS Record Protocol: MAC-Encode-Encrypt}
	\label{fig:tlsrecordprotocol}
\end{figure}

\subsubsection{TLS Record Protocol Sequence Numbers}

When the handshake is done, both client and server set the sequence number to 0 and start counting. Sequence number is 64 bits in size and is incremented for each new message. Once we reach the top (overflow), we throw away the keys and rerun the handshake (however this will rarely happen.. $2^{64}$ is very large).\\
Server and client both each maintain a copy of two seq. numbers: one for sending, one for receiving. Sequence numbers are not transmitted as part of message (TCP already provides reliable transport), however they are included in the MAC. Sequence numbers and MAC together give replay protection.\\
A wrong sequence number leads to a failure of the MAC verification. TLS is thus reliant on TCP to deliver messages in order.


\newpage

\section{Attacks against TLS}

\subsection{Attack on RC4}
\label{attack_on_rc4}

In RC4, we have biases towards certain byte values in the first 256 bytes of the RC4 cipher outputs. For example, at position 16, byte 240 is much more likely.\\
By analyzing \textbf{many} ciphertexts, we can do bayesian analysis and check which byte was most likely at each position. This then allows to recover the plaintext. For example, we could analyze the values at position 16 and XOR the most likely value with 240, which gives the plaintext.\\
An example on how to exploit this is: You want to target a secure cookie in the HTTPS session between a client running a web browser B and a web server W . You know W serves secure cookies over HTTPS, and you control a second web server, E, the client visits. The client will run javascript code served from E. While this code cannot directly access cookies from W (due to the same-origin policy, SOP), it can make requests to W : the cookies will be automatically attached by the browser to the new requests. The javascript can repeat enough requests to make the attack succeed — allowing the attacker to recover the plaintext cookie.

\subsection{FREAK attack}

\begin{figure}[hb]
	\centering
	\begin{subfigure}[t]{.5\textwidth}
		\centering
		\includegraphics[width=\linewidth]{figures/tls_freak_1}
		\label{fig:tls_freak_1}
	\end{subfigure}%
	\begin{subfigure}[t]{.5\textwidth}
		\centering
		\includegraphics[width=\linewidth]{figures/tls_freak_2}
		\label{fig:tls_freak_2}
	\end{subfigure}
\end{figure}

In a FREAK attack, an active MiTM attacker forces a TLS session to use insecure export ciphers. Export ciphers are intentionally weak ciphers that were offered by the US in the 90s. During that time, these ciphers were only breakable with huge resources and a large budget. Today, they are breakable with 100\$ of AWS credit.\\
The active MiTM attacker alters the unencrypted ClientHello message to request Export RSA as the
cipher suite. Similarly, ServerHello message is changed to reflect the original ClientHello. The ServerFinished message also needs to reflect the original ClientHello and ServerHello, with the unchanged cipher suite, otherwise the client would fail transcript verification.\\
The attacker needs to be able to pre-factor the RSA key, (or factor an on-the-fly RSA key “in real time”) and craft a new ServerFinished message, removing the original from the communication channel. Since servers reuse RSA keys, the attacker can just connect to the server in advance and factor the key. Once the attacker has the key, she can decrypt the pre-mastersecret and then generate the mastersecret, using the nonces (which are in plaintext, thus public).\\
This attack was only possible due to buggy TLS client: when requesting export RSA, the server responds with a ServerKeyExchange message which contain the RSA pubKey and RSA signatures on nonces and parameters. For normal RSA (which the client thinks he's using) we would not get this message. Buggy TLS client accepted the weak key and used it, even though a different cipher was requested.\\
FREAK requires an active MiTM. The attacker needs to keep impersonating the server for all new sessions or for possible future CCS+Finish.

\subsection{Heartbleed}

The Heartbeet protocol of TLS is equivalent to ping (icmp), just for TLS. You send a msg to a server, server sends the exact msg back. Turns out, OpenSSL didn't do proper bound checking on the received msg. If you send a short msg but tell the server it's a long message, the server would send a long msg. The server would then just read over the buffer and read into memory. By doing this over and over (and being lucky) you could receive sensitive data such as passwords or private keys.

\subsection{Apple \texttt{goto fail}}

\begin{figure}[hb]
	\centering
	\includegraphics[width=0.5\linewidth]{figures/apple_goto_fail}
	\caption{Apple goto fail in iPhone and Mac TLS library}
	\label{fig:applegotofail}
\end{figure}

\section{TLS 1.3}

Main objectives of TLS 1.3:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Protocol simplification (reducing options and removing broken cipher suites).
	\item Reduce latency of initial secure data communication (1-RTT and 0-RTT for resumed sessions).
	\item Improve security and privacy.
	\item Remove compression, RC4, MAC-then-Encrypt, RSA key transport,	custom DH and ECDH groups, renegotiation.
	\item A stream-oriented API for applications making use of it.
	\item Hence TLS may fragment into smaller records or coalesce into larger records any data supplied by the calling application.
\end{itemize}
\vspace{-\topsep}

\subsection{TLS 1.3 1-RTT handshake}

Basic idea: client sends Hello message which already includes its DH pubKey $g^x$. For this to work, the client needs to guess which DH groups the server supports.
Assuming the server actually supports the DH group it sends a ServerHello with the server DH pubKey AND it can already encrypt data since the server knows the nonces and both DH values.
DH and ECDH groups: A limited set of DH and ECDH groups are supported in TLS 1.3. This reduces likelihood of fall-back to 2-RTT and removes complexity from implementations.

\subsection{TLS 1.3 - Resumption}

Resumption uses pre-shared keys (PSK) which were established in prior session. The client sends a list of PSK IDs, one of which is selected by the server.

\includepdf{doc/tls_summary_1}

\includepdf{doc/tls_summary_2}

\includepdf{doc/tls_summary_3}

\includepdf{doc/tls_summary_4}

\section{VPNs}

A VPN creates a secure channel between two networks over an untrusted network (the Internet). VPNs and end-to-end security (TLS) complement each other. Many different VPN protocols and applications exist (IPsec, Strongswan, OpenVPN, WireGuard, ...)
Typical properties of VPN tunnels:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Similar security properties as the TLS record protocol:
	\begin{itemize}
		\item Authentication of the source, integrity (MACs)
		\item Confidentiality (symmetric encryption)
		\item Replay suppression (sequence numbers)
	\end{itemize}
	\item Some tunneling protocols do not provide encryption or authentication
\end{itemize}
\vspace{-\topsep}

\noindent Typical VPN setups:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item secure connection between two physically separated networks (site-to-site)
	\item secure connection of a remote host to company/university network (host-to-site)
	\item VPN as a “secure” proxy (avoid tracking, spoof location, circumvent censorship)
\end{itemize}
\vspace{-\topsep}

\noindent \textbf{Why do we need VPNs when we have TLS?}

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item If we only want to operate on layer 3 (e.g. company printer network) and still be secure
	\item When only using TLS: we still leak metadata
	\item HTTPS doesn't hide layer 3 information (srcIP, dstIP)
	\item VPNs protect all traffic ('blanket' security): DNS requests, accessing webservers without TLS
	\item VPNs can give access to services in private networks or behind firewalls
	\item VPNs allow to spoof your location
\end{itemize}
\vspace{-\topsep}

\noindent \textbf{Why do we need TLS when we have VPNs?}

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item With VPNs, data is only secure inside the tunnel. But the data needs to somehow get to and from the tunnel. VPNs provide no security outside the tunnel
	\item VPN server can see all unencrypted traffic. TLS is still necessary.
	\item With a VPN it is not possible to authenticate a webserver, only the tunnel endpoint.
	\item VPNs need initial credential setup, TLS can be setup without knowing each other
\end{itemize}
\vspace{-\topsep}

\noindent There are many different VPN protocols but only one TLS. Why?
Because TLS is universal, everybody should be able to access webservers securely through TLS.  We thus need a globally universal standard. VPNs are setup by companies, universities, private person etc. and it only affects their clients, employees etc.. For VPNs, we can thus use whatever we want.

\subsection{IPsec}

IPsec is a very large and complicated protocol. The tunnel is setup at layer 3 (network). In IPsec, we also use sequence numbers (like in TLS) \textit{but} they are included in the packets (while TLS doesn't include sequence numbers in the packet). That's because IPsec runs on top of IP and IP is best-effort transport. The ordering of packets can thus be off at the receiver. That's why sequence numbers need to be in the packets. What if we are tunneling UDP traffic?
The numbers are also there to avoid replay attacks. Each party has a sliding window so that it can
detect if a packet is replayed by inspecting the sequence number.

\subsubsection{Internet key exchange (IKEv2)}

IKE is used to setup a security association (SA). In IKE, we have an anonymous DH exchange. This provides forward security and does not leak identities (as e.g. TLS does) since no authentication data is sent in plaintext. The disadvantage is that anonymous DH is vulnerable to an active MiTM attack.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.9\linewidth]{figures/ikev2}
	\caption{Internet key exchange (IKEv2)}
	\label{fig:ikev2}
\end{figure}

\subsubsection{IPsec session}

After an SA was setup using IKE, we encapsulate packets and tunnel them between SA endpoints. Encapsulation works as follows:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Add ESP trailer: Padding, type encapsulated (original) packet
	\item Encrypt packet and trailer
	\item Add ESP header: SA identification, sequence number
	\item Create Integrity Check Value (ICV): MAC over original packet, ESP	header, ESP trailer
	\item Add new IP header
\end{itemize}
\vspace{-\topsep}

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{figures/ipsec_encapsulation}
	\caption{IPsec encapsulation security payload (ESP) in tunneling mode}
	\label{fig:ipsecencapsulation}
\end{figure}

\noindent Similarly, decapsulation:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Strip off outer IP header
	\item Look up keys and configuration using information in ESP header
	\item Check MAC
	\item Strip off authentication tag and ESP header
	\item Decrypt original packet
	\item Remove ESP trailer
	\item Forward original packet
\end{itemize}
\vspace{-\topsep}

\begin{figure}[hb]
	\centering
	\includegraphics[width=0.7\linewidth]{figures/ipsec_decapsulation}
	\caption{IPsec decapsulation and decryption}
	\label{fig:ipsecdecapsulation}
\end{figure}

\subsection{Wireguard}

WireGuard is a modern lightweight VPN that only has roughly 4000 LOC (opposed to OpenVPN with 600'000 LOC!).\\
WireGuard relies on simple configuration and no cryptographic agility. It only uses state-of-the-art primitives: Curve25519 (signatures), ChaCha20 (encryption), Poly1305 (authentication). The small codebase provides minimal attack surface and is formally verifiable. (Even Linus Torvalds praised his love for WireGuard...)

\subsubsection{Authentication and keys}

Each peer has a static key pair. Initiator: $S_I^{pub}, S_I^{priv}$, Responder: $S_R^{pub}, S_R^{priv}$. Peers specify in configuration which public keys are authorized. WireGuard uses a 1-RTT handshake during which each peer generates an ephemeral key pair: Initiator: $E_I^{pub}, E_I^{priv}$, Responder: $E_R^{pub}, E_R^{priv}$. Symmetric keys are then derived from four DH combinations: $$\{DH(S_I,S_R), DH(S_I,E_R), DH(E_I,S_R), DH(E_I,E_R)\}$$

\begin{figure}[hb]
	\centering
	\includegraphics[width=1\linewidth]{figures/wireguard_handshake}
	\caption{WireGuard 1-RTT handshake}
	\label{fig:wireguardhandshake}
\end{figure}

The WireGuard protocol is connectionless. A series of timers, both based on message counts and time, are used to steer key renegotiation, handshakes and session termination. The strict key rotation timers \texttt{(REKEY\_AFTER\_MESSAGES, REKEY\_AFTER\_TIME)} and the ephemeral
ECDH session key exchange guarantee PFS.

\subsubsection{DoS protection}

Since VPN servers need to do expensive crypto, they are susceptible to (D)DoS attacks. A WireGuard implementation can choose to respond with a cookie instead of processing the handshake: the initiator will then use this cookie as a key for computing HMACs of their message. The cookie mechanism of IKEv2 is very similar to the one just described. However, an important difference between the two is that Wireguard requires an additional MAC on the handshake message — using the public key of the responder as HMAC key. This allows the responder to stay completely silent — not responding even with a cookie — unless the initiator knows its public key. (Remember that “public” key do not need to be publicly accessible, often they are not).

\newpage

\section{Anonymous communication systems}

Why are VPNs not enough? VPN server still sees metadata such as srcIP, dstIP, ports, metadata etc. We need something stronger for anonymous communication. 

\subsection{Terminology: “anonymity”}

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Sender anonymity: adversary knows receiver, may learn message, sender is unknown. The sender anonymity set is the set of all possible senders, which can be used as a (rough) metric. A small set means little anonymity.
	\item Receiver anonymity: Adversary knows sender, may learn message, receiver is unknown. The sender needs a return address: the receiver provides a token (since the sender doesn't know the receiver) and the token will be used to direct the message. Receiver anonymity set is the set of all possible receivers.
	\item (Sender-receiver) unlinkability: Adversary knows senders, knows receivers, link between senders and	receivers is unknown. Multiple users need to communicate at the same time.
	\item Unobservability: Adversary cannot tell whether any communication is taking place.
\end{itemize}
\vspace{-\topsep}

\noindent The following holds: $Unobservability \rightarrow Anonymity \rightarrow Unlinkability$

\subsection{How to send a message anonymously}

\subsubsection{Broadcast}

Receiver anonymity is guaranteed, sender can be de-anonymized (localization through triangulation)!. Alternative: hijacked connection (burner phone, hacked WiFi, network ID ≠ personal sender ID).

\subsubsection{Mixnets}

Simple idea: use a proxy or VPN. The proxy has to be trusted $\rightarrow$ to avoid fully trusting the proxy: Layered encryption. However, the adversary may be able to link inputs
and outputs (timing)!\\\
The proxy should perform \textbf{batching and mixing}. Batching: collect a number of messages
before forwarding (threshold). Mixing: change the order of (mix) the messages.\\
An adversary can still mount an intersection attack: Often, users only communicate with a
small subset of other users. Idea: every time a message is seen by the target, register the sets of destinations. To achieve full unobservability, use \textbf{cover traffic}, both for sending and receiving. Now we are fully anonymous... as long as the mix is trusted!. We should use multiple mixes to avoid single point of failure (cascade). Each mix should only know its direct neighbor and only the first mix should know the sender and only the last mix should know the receiver.\\
\indent How do we handle return addresses? Alice prepares a return address and encloses it in her first message. That address contains layered information.

\subsection{Circuit-based systems (AKA onion-routing system)}

Mix-nets are very secure but very slow. We want a system that can support web browsing. Main ideas: use layered encryption, no batching and mixing, no cover traffic. Flow-based: establish a virtual circuit (keys) once per flow, reuse it for all packets in the flow using only symmetric key crypto. The threat model is constrained: only a local adversary (e.g. ISP) which cannot launch confirmation attacks.\\
\indent \textbf{Terminology:} Circuit-based anonymous communication systems, commonly known as Onion Routing Systems. The nodes are called relays (also nodes or routers). The virtual circuit is also called tunnel.

\subsubsection{Circuit setup}

The sender negotiates shared keys with all relays on the path (this requires expensive asymmetric key cryptography).\\
\noindent \textbf{Direct circuit setup:} a packet is sent through the whole system and returned and at each step the state is generated. The encryption keys of data are only based on public keys of relays. Thus (immediate) FS does not hold since no ephemeral information is used.\\
\noindent \textbf{Telescopic circuit setup:} Keys are negotiated one relay at a time. The circuit is “extended” by one hop at a time (that’s why it is called telescopic). Ephemeral session keys are negotiated before the circuit is extended. This setup is slower... but it offers immediate forward secrecy: As soon as the circuit is closed, the session keys are deleted.

\subsubsection{Data forwarding}

The sender has established a circuit (keys and per-link IDs). A data packet is encrypted as usual (layered encryption). The ID of the next relay is added in clear text. To protect against network adversaries, links can be encrypted (TLS).

\subsubsection{Circuit tear-down}

Can be initiated both by sender and by intermediate relays. The sender communicates the tear-down to one relay at a time, starting from the furthest away. The exit relay may tear down the circuit if a corrupt packet is detected, or some other attack. Circuits have a limited lifetime, so they will eventually be destroyed.

\subsection{Attacks on circuit-based anonymous-communication systems}

Many attacks have been proposed, however for many it is unclear if they fit the standard threat model. Some of them are practical, requiring limited resources. Others are only achievable by state-level adversaries (Five Eyes).

\subsubsection{Fingerprinting}

One general attack is fingerprinting. This can be done in multiple ways:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Passive traffic analysis: The adversary observes the edges of the network, recording traffic patterns.
	\item Active traffic analysis: 
	\begin{itemize}
		\item The adversary actively modifies packet timings: Inter-packet timings (delaying/reordering packets), packet drops also possible but detectable
		\item Flow watermarking: inject one bit of information (marked or not)
		\item Flow fingerprinting: inject multiple bits (e.g., sender IP address!)
	\end{itemize}
	\item Website fingerprinting: Many websites have a distinct pattern of traffic they receive and send. Adversary can keep a database of patterns and compare traffic recorded from a single observation point (ISP, WiFi users,...)
\end{itemize}
\vspace{-\topsep}

\noindent There are two possible approaches on how to defend against fingerprinting:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Randomization: make the fingerprint look random, each user always has a new, random fingerprint.
	\item Uniformity: make all the fingerprints look the same, all the users share a common	fingerprint. This is what the TOR browser tries to enforce. All Tor Browser user supposedly share the same fingerprint, increasing their anonymity set. Numerous patches are used to limit plugins, ask permission for HTML Canvas, restrict WebSockets, reduce available fonts, standardize the User-Agent header, and limit many other fingerprinting techniques. Even window size is considered sensitive: the browser will warn you if you attempt to maximize its window (you would leak the size of your monitor).
\end{itemize}
\vspace{-\topsep}

\noindent In order to prevent fingerprinting, you should omit \textit{everything} that makes you stand out: don't install any plugins, never use TOR in fullscreen mode (gives away your screen resolution), don't type inside the browser, type inside a text-editor and copy-paste messages into webforms, etc.

\subsubsection{Higher-layer attacks}

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item OS Network stack fingerprinting (OS, browser, window size, user-agent, browser plugins, etc.)
	\item Most deanonymization is still done through other means: Trick user into downloading malware, trick user into downloading file that will access the Internet directly, analyze user behavior like texts.
\end{itemize}
\vspace{-\topsep}

\noindent To achieve anonymity, all layers need to be anonymized: Any gap will break anonymity!

\subsection{TOR}

TOR basics:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Circuits established over 3 relays
	\item Telescopic setup (forward secrecy!)
	\item Per-hop TCP, established on the fly to avoid TCP stack fingerprinting
	\item Per-hop TLS (except on the last hop). Multiple circuits over same TLS connection. End-to-end HTTPS is possible.
	\item Main tool: Tor browser (Firefox)
\end{itemize}
\vspace{-\topsep}

\noindent TOR additional features:

\vspace{-\topsep}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\setlength{\parskip}{0pt}
	\item Exit policies (exit can restrict the destinations	they connect to)
	\item Multiple streams per circuit (helps with performance, weakens anonymity)
	\item Censorship resistance (bridges)
	\item Hidden services: Provide receiver anonymity, use .onion URL (not in DNS). The name is the hash of the HS’s public key.
\end{itemize}
\vspace{-\topsep}

\subsubsection{Cells}

If a relay obtains a cell: it looks up keying material from circuit id and will decrypt the payload which contains sets of fields. The relay then checks the digest and if it matches it looks at the cmd.

\begin{figure}[hb]
	\centering
	\includegraphics[width=0.7\linewidth]{figures/tor_cell}
	\caption{TOR cell}
	\label{fig:torcell}
\end{figure}

\subsubsection{Directory authorities}

How do the clients know what relays there are? 10 directory authorities (servers) running a consensus algorithm. The authorities track the state of relays, store their public keys. Client software (Tor browser) comes with a list of the authorities’ keys (If an adversary can supply the list, de-anonymization is trivial!). A client accepts a consensus document if signed by ≥ 50\%. The centralized authorities are an important weakness of Tor. An adversary compromising 5 authorities can compromise Tor. Every relay periodically reports a signed statement (state, stats.) DAs also act as bandwidth authorities: verify bandwidth of nodes.\\
Sybil protection: DAs limit the number of relays per IP subnet.

\subsubsection{Censorship resistance in Tor}

The Tor network contains a number of bridge relays (or bridges). Not (all) publicly listed, instead distributed through friends networks. This is used to circumvent censors which black-list Tor relays. Problem: deep packet inspection allows detection of Tor traffic
Solution: obfuscate the traffic (pluggable transports)

\subsubsection{Circuit setup}

Who is authenticated on the first hop? Alice is \textit{not}. The entry guard is since Alice encrypted her ephemeral DH value $g^{x_1}$ with the entry guard's pubKey. The entry guard then sends back $g^{y_1}$ and a hash of $g^{x_1y_1}$ which it can only do if it was able to decrypt $g^{x_1}$ which it can only do if it has the privKey.
\begin{figure}[hb]
	\centering
	\includegraphics[width=0.9\linewidth]{figures/tor_circuit_setup}
	\caption{Circuit setup with three hops}
	\label{fig:torcircuitsetup}
\end{figure}





\label{lastpage} % this must stay here
\clearpage
\addcontentsline{toc}{section}{References}
\bibliographystyle{acm}
\bibliography{refs}

\clearpage
\appendix
\pagenumbering{Roman}

\end{document}
